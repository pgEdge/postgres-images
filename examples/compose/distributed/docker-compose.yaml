services:
  postgres-n1:
    image: ${POSTGRES_IMAGE:-ghcr.io/pgedge/pgedge-postgres:17-spock5-standard}
    container_name: postgres-n1
    restart: always
    environment:
      PGEDGE_USER: pgedge
      PGEDGE_PASSWORD: pgedge
      POSTGRES_USER: pgedge
      POSTGRES_PASSWORD: pgedge
      POSTGRES_DB: example_db
      NODE_NAME: n1
    ports:
      - target: 5432
        published: 6432
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB} -h 127.0.0.1 -p 5432"]
      interval: 5s
      timeout: 3s
      retries: 20
    configs:
      - source: init-extensions
        target: /docker-entrypoint-initdb.d/10-init-extensions.sh
        mode: 0755
      - source: configure-spock
        target: /docker-entrypoint-initdb.d/20-configure-spock.sh
        mode: 0755
      - source: restart-postgres
        target: /docker-entrypoint-initdb.d/30-restart-postgres.sh
        mode: 0755
      - source: create-extensions
        target: /docker-entrypoint-initdb.d/40-create-extensions.sh
        mode: 0755
      - source: relax-pg-hba
        target: /docker-entrypoint-initdb.d/45-relax-pg-hba.sh
        mode: 0755
      - source: spock-node
        target: /docker-entrypoint-initdb.d/50-spock-nodes.sh
        mode: 0755

  postgres-n2:
    image: ${POSTGRES_IMAGE:-ghcr.io/pgedge/pgedge-postgres:17-spock5-standard}
    container_name: postgres-n2
    restart: always
    environment:
      PGEDGE_USER: pgedge
      PGEDGE_PASSWORD: pgedge
      POSTGRES_USER: pgedge
      POSTGRES_PASSWORD: pgedge
      POSTGRES_DB: example_db
      NODE_NAME: n2
    ports:
      - target: 5432
        published: 6433
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB} -h 127.0.0.1 -p 5432"]
      interval: 5s
      timeout: 3s
      retries: 20
    configs:
      - source: init-extensions
        target: /docker-entrypoint-initdb.d/10-init-extensions.sh
        mode: 0755
      - source: configure-spock
        target: /docker-entrypoint-initdb.d/20-configure-spock.sh
        mode: 0755
      - source: restart-postgres
        target: /docker-entrypoint-initdb.d/30-restart-postgres.sh
        mode: 0755
      - source: create-extensions
        target: /docker-entrypoint-initdb.d/40-create-extensions.sh
        mode: 0755
      - source: relax-pg-hba
        target: /docker-entrypoint-initdb.d/45-relax-pg-hba.sh
        mode: 0755
      - source: spock-node
        target: /docker-entrypoint-initdb.d/50-spock-nodes.sh
        mode: 0755

  # Generic wiring job: loops over all nodes in NODES and creates all pairwise subscriptions.
  spock-wire:
    image: ${POSTGRES_IMAGE:-ghcr.io/pgedge/pgedge-postgres:17-spock5-standard}
    container_name: spock-wire
    depends_on:
      postgres-n1:
        condition: service_healthy
      postgres-n2:
        condition: service_healthy

    environment:
      PGUSER: pgedge
      PGPASSWORD: pgedge
      DBNAME: example_db
      # Format: name:host:port entries separated by commas. Add more nodes as needed.
      NODES: "n1:postgres-n1:5432,n2:postgres-n2:5432"
    command: ["/bin/bash", "/wire/run.sh"]
    restart: "no"
    configs:
      - source: spock-wire-script
        target: /wire/run.sh
        mode: 0755

configs:
  init-extensions:
    content: |-
      #!/usr/bin/env bash
      set -Eeo pipefail
      EXTENSIONS=("pg_stat_statements" "pgaudit" "snowflake" "spock" "postgis-3")
      PGCONF="$$PGDATA/postgresql.conf"
      echo "Setting shared_preload_libraries to: $${EXTENSIONS[*]}"
      LIBS=$$(IFS=','; echo "$${EXTENSIONS[*]}")
      if grep -q '^[ ]*shared_preload_libraries' "$$PGCONF"; then
        sed -i "s|^[ ]*shared_preload_libraries.*|shared_preload_libraries = '$$LIBS'|" "$$PGCONF"
      else
        echo "shared_preload_libraries = '$$LIBS'" >> "$$PGCONF"
      fi

  configure-spock:
    content: |-
      #!/usr/bin/env bash
      set -Eeo pipefail
      PGCONF="$$PGDATA/postgresql.conf"
      echo "Initializing Spock + logical replication configuration in postgresql.conf"

      echo "listen_addresses = '*'"              >> "$$PGCONF"
      echo "wal_level = 'logical'"              >> "$$PGCONF"
      echo "max_worker_processes = 10"          >> "$$PGCONF"
      echo "max_replication_slots = 10"         >> "$$PGCONF"
      echo "max_wal_senders = 10"               >> "$$PGCONF"
      echo "track_commit_timestamp = 'on'"      >> "$$PGCONF"

      echo "spock.enable_ddl_replication = 'on'"       >> "$$PGCONF"
      echo "spock.include_ddl_repset = 'on'"           >> "$$PGCONF"
      echo "spock.allow_ddl_from_functions = 'on'"     >> "$$PGCONF"
      echo "spock.conflict_resolution = 'last_update_wins'" >> "$$PGCONF"
      echo "spock.save_resolutions = 'on'"             >> "$$PGCONF"
      echo "spock.conflict_log_level = 'DEBUG'"        >> "$$PGCONF"

  restart-postgres:
    content: |-
      #!/usr/bin/env bash
      set -Eeo pipefail
      echo "Mid-sequence restart to apply base configuration..."
      pg_ctl -D "$$PGDATA" -m fast restart

  create-extensions:
    content: |-
      #!/usr/bin/env bash
      set -Eeo pipefail
      EXTENSIONS=("pg_stat_statements" "pgaudit" "snowflake" "spock" "postgis")
      echo "Initializing extensions: $${EXTENSIONS[*]}"
      for EXT in "$${EXTENSIONS[@]}"; do
        echo "Creating extension: $$EXT"
        psql -v ON_ERROR_STOP=1 --username "$$POSTGRES_USER" --dbname "$$POSTGRES_DB" \
          -c "CREATE EXTENSION IF NOT EXISTS \"$$EXT\";"
      done

  relax-pg-hba:
    content: |-
      #!/usr/bin/env bash
      set -Eeo pipefail
      echo "host all all 0.0.0.0/0 md5" >> "$$PGDATA/pg_hba.conf"
      echo "host all all ::/0 md5"     >> "$$PGDATA/pg_hba.conf"
      pg_ctl -D "$$PGDATA" -m fast reload

  # Per-node setup: create the local spock node idempotently.
  spock-node:
    content: |-
      #!/usr/bin/env bash
      set -Eeo pipefail

      : "$${NODE_NAME:?NODE_NAME not set}"
      DB="$${POSTGRES_DB:-example_db}"
      USER="$${POSTGRES_USER:-pgedge}"
      PASS="$${POSTGRES_PASSWORD:-pgedge}"
      HOST="postgres-$${NODE_NAME}"
      PORT="$${PGPORT:-5432}"

      export PGPASSWORD="$${PASS}"

      echo "[spock-node] Ensuring spock node '$${NODE_NAME}' exists (dsn host=$${HOST} port=$${PORT})..."
      EXISTS=$$(psql -v ON_ERROR_STOP=0 --username "$${USER}" --dbname "$${DB}" -t -A \
        -c "SELECT 1 FROM spock.node WHERE node_name = '$${NODE_NAME}' LIMIT 1;" || true)

      if [ -z "$$EXISTS" ]; then
        psql -v ON_ERROR_STOP=1 --username "$${USER}" --dbname "$${DB}" \
          -c "SELECT spock.node_create(node_name := '$${NODE_NAME}', dsn := 'host=$${HOST} port=$${PORT} dbname=$${DB} user=$${USER} password=$${PASS}');"
        echo "[spock-node] node '$${NODE_NAME}' created."
      else
        echo "[spock-node] node '$${NODE_NAME}' already present; skipping."
      fi

  # Wiring script: builds full-mesh subscriptions across all nodes in NODES.
  spock-wire-script:
    content: |-
      #!/usr/bin/env bash
      set -Eeo pipefail

      : "$${NODES:?NODES list is required, e.g. NODES='n1:postgres-n1:5432,n2:postgres-n2:5432'}"
      : "$${PGUSER:?PGUSER required}"
      : "$${PGPASSWORD:?PGPASSWORD required}"
      : "$${DBNAME:?DBNAME required}"

      IFS=',' read -r -a NODE_ENTRIES <<< "$$NODES"

      # Parse into arrays
      NAMES=()
      HOSTS=()
      PORTS=()
      for entry in "$${NODE_ENTRIES[@]}"; do
        name="$${entry%%:*}"
        rest="$${entry#*:}"
        host="$${rest%%:*}"
        port="$${rest##*:}"
        NAMES+=("$$name"); HOSTS+=("$$host"); PORTS+=("$$port")
      done

      psql_ok () {
        local host="$$1" port="$$2" sql="$$3"
        PGPASSWORD="$$PGPASSWORD" psql -h "$$host" -p "$$port" -U "$$PGUSER" -d "$$DBNAME" -t -A -v ON_ERROR_STOP=1 -c "$$sql" >/dev/null 2>&1
      }

      echo "[wire] Waiting for all nodes to be reachable..."
      for i in "$${!NAMES[@]}"; do
        h="$${HOSTS[$$i]}"; p="$${PORTS[$$i]}"
        until psql_ok "$$h" "$$p" "select 1"; do
          echo "[wire] waiting for $$h:$$p ..."
          sleep 1
        done
      done

      echo "[wire] Waiting until each DB reports its own spock.node row..."
      for i in "$${!NAMES[@]}"; do
        n="$${NAMES[$$i]}"; h="$${HOSTS[$$i]}"; p="$${PORTS[$$i]}"
        until PGPASSWORD="$$PGPASSWORD" psql -h "$$h" -p "$$p" -U "$$PGUSER" -d "$$DBNAME" -t -A -c "SELECT 1 FROM spock.node WHERE node_name='$$n' LIMIT 1;" | grep -q '^1$$'; do
          echo "[wire] waiting for spock.node '$$n' on $$h:$$p ..."
          sleep 1
        done
      done

      echo "[wire] Creating full-mesh subscriptions (idempotent)..."
      # For every ordered pair (A,B), A!=B, ensure sub_A_B exists pointing to B
      for i in "$${!NAMES[@]}"; do
        ai="$${NAMES[$$i]}"; ah="$${HOSTS[$$i]}"; ap="$${PORTS[$$i]}"
        for j in "$${!NAMES[@]}"; do
          [ "$$i" -eq "$$j" ] && continue
          bj="$${NAMES[$$j]}"; bh="$${HOSTS[$$j]}"; bp="$${PORTS[$$j]}"
          sub="sub_$${ai}_$${bj}"
          echo "[wire] ensuring $$sub exists on $$ai -> $$bj ..."
          # single-line SQL to avoid YAML/heredoc pitfalls
          PGPASSWORD="$$PGPASSWORD" psql -h "$$ah" -p "$$ap" -U "$$PGUSER" -d "$$DBNAME" -v ON_ERROR_STOP=1 \
            -c "SELECT spock.sub_create(subscription_name := '$$sub', provider_dsn := 'host=$$bh port=$$bp dbname=$$DBNAME user=$$PGUSER password=$$PGPASSWORD') WHERE NOT EXISTS (SELECT 1 FROM spock.subscription WHERE sub_name='$$sub');" \
            >/dev/null
        done
      done

      echo "[wire] Wiring complete."
